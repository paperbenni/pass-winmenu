using System;
using System.IO.Abstractions;
using System.Linq;
using LibGit2Sharp;
using PassWinmenu.ExternalPrograms.Gpg;
using PassWinmenu.WinApi;

#nullable enable
namespace PassWinmenu.ExternalPrograms
{
	/// <inheritdoc cref="IDisposable" />
	/// <summary>
	/// Simple wrapper over git.
	/// </summary>
	internal class Git : IDisposable, ISyncService
	{
		private readonly IRepository repo;
		private readonly IDirectoryInfo repoDirectory;
		private readonly IGitSyncStrategy gitSyncStrategy;
		private readonly ISignService signService;

		/// <summary>
		/// Initialises the wrapper.
		/// </summary>
		/// <param name="repo">The repository git should operate on.</param>
		/// <param name="gitSyncStrategy">The strategy to use for synchronising repository changes.</param>
		public Git(IRepository repo, IDirectoryInfo repoDirectory, IGitSyncStrategy gitSyncStrategy, ISignService signService)
		{
			this.repo = repo;
			this.repoDirectory = repoDirectory;
			this.gitSyncStrategy = gitSyncStrategy;
			this.signService = signService;
		}

		public TrackingDetails GetTrackingDetails()
		{
			var trackingDetails = repo.Head.TrackingDetails;
			return new TrackingDetails
			{
				AheadBy = trackingDetails.AheadBy ?? 0,
				BehindBy = trackingDetails.BehindBy ?? 0,
			};
		}

		/// <summary>
		/// Rebases the current branch onto the branch it is tracking.
		/// </summary>
		public void Rebase()
		{
			var head = repo.Head;
			var tracked = head.TrackedBranch;

			var sig = BuildSignature();

			var result = repo.Rebase.Start(head, tracked, null, new Identity(sig.Name, sig.Email), new RebaseOptions());
			if (result.Status != RebaseStatus.Complete)
			{
				repo.Rebase.Abort();
				throw new GitException($"Could not rebase {head.FriendlyName} onto {head.TrackedBranch.FriendlyName}");
			}
			else if (result.CompletedStepCount > 0)
			{
				Log.Send($"Successfully rebased {head.FriendlyName} onto {head.TrackedBranch.Tip.Sha} in {result.CompletedStepCount} step(s).");
			}
			else
			{
				Log.Send($"No rebase needed (no upstream changes, or fast-forward possible)");
			}
		}

		public void Fetch()
		{
			gitSyncStrategy.Fetch(repo.Head);
		}

		public void Push()
		{
			gitSyncStrategy.Push();
		}

		public RepositoryStatus Commit()
		{
			UnstageAll();

			var status = repo.RetrieveStatus();
			var filesToCommit = status.Where(f => f.State != FileStatus.Ignored);

			foreach (var entry in filesToCommit)
			{
				CommitFile(entry.FilePath);
			}

			return status;
		}

		public void EditPassword(string passwordFilePath)
		{
			CommitFile(passwordFilePath);
		}

		public void AddPassword(string passwordFilePath)
		{
			CommitFile(passwordFilePath);
		}

		public void Dispose()
		{
			repo?.Dispose();
		}

		private void CommitFile(string filePath)
		{
			var status = repo.RetrieveStatus(filePath);
			if (status == FileStatus.Nonexistent)
			{
				// This file does not exist in the repository.
				// It may be located inside a submodule, making it difficult to handle correctly
				// until we implement full submodule support. For now, we'll just ignore it.
				return;
			}
			Commands.Stage(repo, filePath);

			var relativePath = PathUtilities.MakeRelativePathForDisplay(repoDirectory, filePath);
			var message = $"{GetVerbFromGitFileStatus(status)} password store file {relativePath}\n\n" +
						  "This commit was automatically generated by pass-winmenu.";
			var tree = repo.ObjectDatabase.CreateTree(repo.Index);

			var commitSignature = BuildSignature();
			var sign = repo.Config.Get<bool>("commit.gpgsign");
			if (sign?.Value ?? false)
			{
				Log.Send($"Generating GPG signature for {filePath}");
				var keyId = repo.Config.Get<string>("user.signingkey");
				if (string.IsNullOrWhiteSpace(keyId.Value))
				{
					throw new GitException($"Unable to sign commit (no signing key set).");
				}

				var commitBuffer = LibGit2Sharp.Commit.CreateBuffer(
					commitSignature,
					commitSignature,
					message,
					tree,
					new[] { repo.Head.Tip },
					true,
					null);

				var gpgSignature = signService.Sign(commitBuffer, keyId.Value);
				var signedCommit = repo.ObjectDatabase.CreateCommitWithSignature(commitBuffer, string.Join("\n", gpgSignature));
				repo.Refs.UpdateTarget(repo.Refs.Head.ResolveToDirectReference(), signedCommit);
			}
			else
			{
				Log.Send($"Generating unsigned commit for {filePath}");
				repo.Commit(message, commitSignature, commitSignature);
			}
		}

		private static string GetVerbFromGitFileStatus(FileStatus status)
		{
			return status switch
			{
				FileStatus.DeletedFromWorkdir => "Delete",
				FileStatus.NewInWorkdir => "Add",
				FileStatus.ModifiedInWorkdir => "Edit",
				FileStatus.RenamedInWorkdir => "Rename",
				FileStatus.TypeChangeInWorkdir => "Change filetype for",
				_ => throw new GitException($"Can't determine commit verb for file status '{status}'"),
			};
		}

		private void UnstageAll()
		{
			var status = repo.RetrieveStatus();
			var staged = status.Where(IsStaged).ToList();
			if (staged.Any())
			{
				Commands.Unstage(repo, staged.Select(entry => entry.FilePath));
			}
		}

		private bool IsStaged(StatusEntry entry)
		{
			const FileStatus modified = FileStatus.DeletedFromIndex
				| FileStatus.ModifiedInIndex
				| FileStatus.NewInIndex
				| FileStatus.RenamedInIndex
				| FileStatus.TypeChangeInIndex;

			return (entry.State & modified) > 0;
		}

		private Signature BuildSignature()
		{
			var sig = repo.Config.BuildSignature(DateTimeOffset.Now);
			if (sig == null)
			{
				throw new GitException("Could not build Git signature. Make sure 'user.name' and 'user.email' are configured for the repository.");
			}
			return sig;
		}
	}
}
